// Generated by JavaCPP version 1.5.4: DO NOT EDIT THIS FILE

#define ENABLE_OPENGL_INTEROP
#define WIN32
#define OS_WIN
#define VK_ENABLE_BETA_EXTENSIONS
#define VK_USE_PLATFORM_WIN32_KHR
#define SHARED_PTR_NAMESPACE std
#define UNIQUE_PTR_NAMESPACE std
#define VKT_ENABLE_GLFW_SUPPORT

#ifdef _WIN32
    #define _JAVASOFT_JNI_MD_H_

    #define JNIEXPORT __declspec(dllexport)
    #define JNIIMPORT __declspec(dllimport)
    #define JNICALL __stdcall

    typedef int jint;
    typedef long long jlong;
    typedef signed char jbyte;
#elif defined(__GNUC__) && !defined(__ANDROID__)
    #define _JAVASOFT_JNI_MD_H_

    #define JNIEXPORT __attribute__((visibility("default")))
    #define JNIIMPORT
    #define JNICALL

    typedef int jint;
    typedef long long jlong;
    typedef signed char jbyte;
#endif

#include <jni.h>

#ifdef __ANDROID__
    #include <android/log.h>
#elif defined(__APPLE__) && defined(__OBJC__)
    #include <TargetConditionals.h>
    #include <Foundation/Foundation.h>
#endif

#ifdef __linux__
    #include <malloc.h>
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <sys/sysinfo.h>
    #include <fcntl.h>
    #include <unistd.h>
    #include <dlfcn.h>
    #include <link.h>
    #include <pthread.h>
#elif defined(__APPLE__)
    #include <sys/types.h>
    #include <sys/sysctl.h>
    #include <mach/mach_init.h>
    #include <mach/mach_host.h>
    #include <mach/task.h>
    #include <unistd.h>
    #include <dlfcn.h>
    #include <mach-o/dyld.h>
    #include <pthread.h>
#elif defined(_WIN32) && !defined(NO_WINDOWS_H)
    #define NOMINMAX
    #include <windows.h>
    #include <psapi.h>
#elif defined(_WIN32)
    extern "C" unsigned long __stdcall GetCurrentThreadId();
#endif

#if defined(__ANDROID__) || TARGET_OS_IPHONE
    #define NewWeakGlobalRef(obj) NewGlobalRef(obj)
    #define DeleteWeakGlobalRef(obj) DeleteGlobalRef(obj)
#endif

#include <limits.h>
#include <stddef.h>
#ifndef _WIN32
    #include <stdint.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <exception>
#include <memory>
#include <new>

#define jlong_to_ptr(a) ((void*)(uintptr_t)(a))
#define ptr_to_jlong(a) ((jlong)(uintptr_t)(a))

#if defined(_MSC_VER)
    #define JavaCPP_noinline __declspec(noinline)
    #define JavaCPP_hidden /* hidden by default */
#elif defined(__GNUC__)
    #define JavaCPP_noinline __attribute__((noinline)) __attribute__ ((unused))
    #define JavaCPP_hidden   __attribute__((visibility("hidden"))) __attribute__ ((unused))
#else
    #define JavaCPP_noinline
    #define JavaCPP_hidden
#endif
#if __cplusplus >= 201103L || _MSC_VER >= 1900
    #define JavaCPP_override override
#else
    #define JavaCPP_override
#endif

#include "./include/vkt3/fw.hpp"
#include "./include/stdafx.h"

static JavaVM* JavaCPP_vm = NULL;
static bool JavaCPP_haveAllocObject = false;
static bool JavaCPP_haveNonvirtual = false;
static const char* JavaCPP_classNames[55] = {
        "org/bytedeco/javacpp/Pointer",
        "java/lang/String",
        "org/bytedeco/javacpp/Pointer$NativeDeallocator",
        "org/bytedeco/javacpp/Loader",
        "java/nio/Buffer",
        "java/lang/Object",
        "com/helixd2s/valera/ValerABase$Framebuffer",
        "java/lang/RuntimeException",
        "java/lang/NullPointerException",
        "com/helixd2s/valera/ValerACore$Framebuffer",
        "com/helixd2s/valera/VKt$ImageRegion",
        "com/helixd2s/valera/ValerABase$PipelineLayout",
        "com/helixd2s/valera/ValerACore$PipelineLayout",
        "org/bytedeco/javacpp/LongPointer",
        "com/helixd2s/valera/ValerABase$Rasterization",
        "com/helixd2s/valera/ValerACore$Rasterization",
        "com/helixd2s/valera/ValerABase$RayTracing",
        "com/helixd2s/valera/ValerACore$RayTracing",
        "com/helixd2s/valera/ValerABase$BuildCommand",
        "com/helixd2s/valera/ValerACore$BuildCommand",
        "com/helixd2s/valera/ValerABase$RenderCommand",
        "com/helixd2s/valera/ValerACore$RenderCommand",
        "com/helixd2s/valera/ValerABase$SamplerSet",
        "com/helixd2s/valera/ValerACore$SamplerSet",
        "com/helixd2s/valera/ValerABase$TextureSet",
        "com/helixd2s/valera/ValerACore$TextureSet",
        "com/helixd2s/valera/ValerABase$BufferViewSet",
        "com/helixd2s/valera/VKt$Vector",
        "com/helixd2s/valera/ValerACore$BufferViewSet",
        "com/helixd2s/valera/ValerABase$Background",
        "com/helixd2s/valera/ValerACore$Background",
        "com/helixd2s/valera/ValerABase$GeometrySet",
        "com/helixd2s/valera/ValerACore$GeometryDesc",
        "com/helixd2s/valera/ValerACore$GeometrySet",
        "com/helixd2s/valera/ValerABase$Geometry",
        "com/helixd2s/valera/ValerACore$Geometry",
        "com/helixd2s/valera/ValerABase$Acceleration",
        "com/helixd2s/valera/ValerACore$Acceleration",
        "com/helixd2s/valera/ValerABase$VertexSet",
        "com/helixd2s/valera/ValerACore$VertexSet",
        "com/helixd2s/valera/ValerABase$InstanceSet",
        "com/helixd2s/valera/ValerACore$VsGeometryInstance",
        "com/helixd2s/valera/ValerACore$InstanceSet",
        "com/helixd2s/valera/ValerABase$Constants",
        "com/helixd2s/valera/ValerACore$ConstantDesc",
        "com/helixd2s/valera/ValerACore$Constants",
        "com/helixd2s/valera/ValerABase$MaterialSet",
        "com/helixd2s/valera/ValerACore$MaterialUnit",
        "com/helixd2s/valera/ValerACore$MaterialSet",
        "com/helixd2s/valera/ValerABase$BindingSet",
        "com/helixd2s/valera/ValerACore$BindingSet",
        "com/helixd2s/valera/ValerABase$AttributeSet",
        "com/helixd2s/valera/ValerACore$AttributeSet",
        "com/helixd2s/valera/ValerABase$SetBase",
        "com/helixd2s/valera/ValerACore$SetBase" };
static jclass JavaCPP_classes[55] = { NULL };
static jfieldID JavaCPP_addressFID = NULL;
static jfieldID JavaCPP_positionFID = NULL;
static jfieldID JavaCPP_limitFID = NULL;
static jfieldID JavaCPP_capacityFID = NULL;
static jfieldID JavaCPP_deallocatorFID = NULL;
static jfieldID JavaCPP_ownerAddressFID = NULL;
static jmethodID JavaCPP_initMID = NULL;
static jmethodID JavaCPP_arrayMID = NULL;
static jmethodID JavaCPP_arrayOffsetMID = NULL;
static jfieldID JavaCPP_bufferPositionFID = NULL;
static jfieldID JavaCPP_bufferLimitFID = NULL;
static jfieldID JavaCPP_bufferCapacityFID = NULL;
static jmethodID JavaCPP_stringMID = NULL;
static jmethodID JavaCPP_getBytesMID = NULL;
static jmethodID JavaCPP_toStringMID = NULL;

static inline void JavaCPP_log(const char* fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
#ifdef __ANDROID__
    __android_log_vprint(ANDROID_LOG_ERROR, "javacpp", fmt, ap);
#elif defined(__APPLE__) && defined(__OBJC__)
    NSLogv([NSString stringWithUTF8String:fmt], ap);
#else
    vfprintf(stderr, fmt, ap);
    fprintf(stderr, "\n");
#endif
    va_end(ap);
}

#ifdef __ANDROID__
    static pthread_key_t JavaCPP_current_env;
    static JavaCPP_noinline void JavaCPP_detach_env(void *data)
    {
        if (JavaCPP_vm) {
            JavaCPP_vm->DetachCurrentThread();
        }
    }
    static JavaCPP_noinline void JavaCPP_create_pthread_key(void)
    {
        pthread_key_create(&JavaCPP_current_env, JavaCPP_detach_env);
    }
#endif

static JavaCPP_noinline jclass JavaCPP_getClass(JNIEnv* env, int i) {
    if (JavaCPP_classes[i] == NULL && env->PushLocalFrame(1) == 0) {
        jclass cls = env->FindClass(JavaCPP_classNames[i]);
        if (cls == NULL || env->ExceptionCheck()) {
            JavaCPP_log("Error loading class %s.", JavaCPP_classNames[i]);
            return NULL;
        }
        JavaCPP_classes[i] = (jclass)env->NewWeakGlobalRef(cls);
        if (JavaCPP_classes[i] == NULL || env->ExceptionCheck()) {
            JavaCPP_log("Error creating global reference of class %s.", JavaCPP_classNames[i]);
            return NULL;
        }
        env->PopLocalFrame(NULL);
    }
    return JavaCPP_classes[i];
}

static JavaCPP_noinline jfieldID JavaCPP_getFieldID(JNIEnv* env, int i, const char* name, const char* sig) {
    jclass cls = JavaCPP_getClass(env, i);
    if (cls == NULL) {
        return NULL;
    }
    jfieldID fid = env->GetFieldID(cls, name, sig);
    if (fid == NULL || env->ExceptionCheck()) {
        JavaCPP_log("Error getting field ID of %s/%s", JavaCPP_classNames[i], name);
        return NULL;
    }
    return fid;
}

static JavaCPP_noinline jmethodID JavaCPP_getMethodID(JNIEnv* env, int i, const char* name, const char* sig) {
    jclass cls = JavaCPP_getClass(env, i);
    if (cls == NULL) {
        return NULL;
    }
    jmethodID mid = env->GetMethodID(cls, name, sig);
    if (mid == NULL || env->ExceptionCheck()) {
        JavaCPP_log("Error getting method ID of %s/%s", JavaCPP_classNames[i], name);
        return NULL;
    }
    return mid;
}

static JavaCPP_noinline jmethodID JavaCPP_getStaticMethodID(JNIEnv* env, int i, const char* name, const char* sig) {
    jclass cls = JavaCPP_getClass(env, i);
    if (cls == NULL) {
        return NULL;
    }
    jmethodID mid = env->GetStaticMethodID(cls, name, sig);
    if (mid == NULL || env->ExceptionCheck()) {
        JavaCPP_log("Error getting static method ID of %s/%s", JavaCPP_classNames[i], name);
        return NULL;
    }
    return mid;
}

static JavaCPP_noinline jobject JavaCPP_createPointer(JNIEnv* env, int i, jclass cls = NULL) {
    if (cls == NULL && (cls = JavaCPP_getClass(env, i)) == NULL) {
        return NULL;
    }
    if (JavaCPP_haveAllocObject) {
        return env->AllocObject(cls);
    } else {
        jmethodID mid = env->GetMethodID(cls, "<init>", "(Lorg/bytedeco/javacpp/Pointer;)V");
        if (mid == NULL || env->ExceptionCheck()) {
            JavaCPP_log("Error getting Pointer constructor of %s, while VM does not support AllocObject()", JavaCPP_classNames[i]);
            return NULL;
        }
        return env->NewObject(cls, mid, NULL);
    }
}

static JavaCPP_noinline void JavaCPP_initPointer(JNIEnv* env, jobject obj, const void* ptr, jlong size, void* owner, void (*deallocator)(void*)) {
    if (owner != NULL && deallocator != NULL) {
        jvalue args[4];
        args[0].j = ptr_to_jlong(ptr);
        args[1].j = size;
        args[2].j = ptr_to_jlong(owner);
        args[3].j = ptr_to_jlong(deallocator);
        if (JavaCPP_haveNonvirtual) {
            env->CallNonvirtualVoidMethodA(obj, JavaCPP_getClass(env, 0), JavaCPP_initMID, args);
        } else {
            env->CallVoidMethodA(obj, JavaCPP_initMID, args);
        }
    } else {
        env->SetLongField(obj, JavaCPP_addressFID, ptr_to_jlong(ptr));
        env->SetLongField(obj, JavaCPP_limitFID, (jlong)size);
        env->SetLongField(obj, JavaCPP_capacityFID, (jlong)size);
    }
}

static JavaCPP_noinline jstring JavaCPP_createString(JNIEnv* env, const char* ptr) {
    if (ptr == NULL) {
        return NULL;
    }
#ifdef MODIFIED_UTF8_STRING
    return env->NewStringUTF(ptr);
#else
    size_t length = strlen(ptr);
    jbyteArray bytes = env->NewByteArray(length < INT_MAX ? length : INT_MAX);
    env->SetByteArrayRegion(bytes, 0, length < INT_MAX ? length : INT_MAX, (signed char*)ptr);
    return (jstring)env->NewObject(JavaCPP_getClass(env, 1), JavaCPP_stringMID, bytes);
#endif
}

class JavaCPP_hidden JavaCPP_exception : public std::exception {
public:
    JavaCPP_exception(const char* str) throw() {
        if (str == NULL) {
            strcpy(msg, "Unknown exception.");
        } else {
            strncpy(msg, str, sizeof(msg));
            msg[sizeof(msg) - 1] = 0;
        }
    }
    virtual const char* what() const throw() { return msg; }
    char msg[1024];
};

#ifndef GENERIC_EXCEPTION_CLASS
#define GENERIC_EXCEPTION_CLASS std::exception
#endif
#ifndef GENERIC_EXCEPTION_TOSTRING
#define GENERIC_EXCEPTION_TOSTRING what()
#endif
static JavaCPP_noinline jthrowable JavaCPP_handleException(JNIEnv* env, int i) {
    jstring str = NULL;
    try {
        throw;
    } catch (GENERIC_EXCEPTION_CLASS& e) {
        str = JavaCPP_createString(env, e.GENERIC_EXCEPTION_TOSTRING);
    } catch (...) {
        str = JavaCPP_createString(env, "Unknown exception.");
    }
    jmethodID mid = JavaCPP_getMethodID(env, i, "<init>", "(Ljava/lang/String;)V");
    if (mid == NULL) {
        return NULL;
    }
    return (jthrowable)env->NewObject(JavaCPP_getClass(env, i), mid, str);
}

static JavaCPP_noinline void* JavaCPP_getPointerOwner(JNIEnv* env, jobject obj) {
    if (obj != NULL) {
        jobject deallocator = env->GetObjectField(obj, JavaCPP_deallocatorFID);
        if (deallocator != NULL && env->IsInstanceOf(deallocator, JavaCPP_getClass(env, 2))) {
            return jlong_to_ptr(env->GetLongField(deallocator, JavaCPP_ownerAddressFID));
        }
    }
    return NULL;
}

#include <vector>
template<typename P, typename T = P, typename A = std::allocator<T> > class JavaCPP_hidden VectorAdapter {
public:
    VectorAdapter(const P* ptr, typename std::vector<T,A>::size_type size, void* owner) : ptr((P*)ptr), size(size), owner(owner),
        vec2(ptr ? std::vector<T,A>((P*)ptr, (P*)ptr + size) : std::vector<T,A>()), vec(vec2) { }
    VectorAdapter(const std::vector<T,A>& vec) : ptr(0), size(0), owner(0), vec2(vec), vec(vec2) { }
    VectorAdapter(      std::vector<T,A>& vec) : ptr(0), size(0), owner(0), vec(vec) { }
    VectorAdapter(const std::vector<T,A>* vec) : ptr(0), size(0), owner(0), vec(*(std::vector<T,A>*)vec) { }
    void assign(P* ptr, typename std::vector<T,A>::size_type size, void* owner) {
        this->ptr = ptr;
        this->size = size;
        this->owner = owner;
        vec.assign(ptr, ptr + size);
    }
    static void deallocate(void* owner) { operator delete(owner); }
    operator P*() {
        if (vec.size() > size) {
            ptr = (P*)(operator new(sizeof(P) * vec.size(), std::nothrow_t()));
        }
        if (ptr) {
            std::copy(vec.begin(), vec.end(), ptr);
        }
        size = vec.size();
        owner = ptr;
        return ptr;
    }
    operator const P*()        { size = vec.size(); return &vec[0]; }
    operator std::vector<T,A>&() { return vec; }
    operator std::vector<T,A>*() { return ptr ? &vec : 0; }
    P* ptr;
    typename std::vector<T,A>::size_type size;
    void* owner;
    std::vector<T,A> vec2;
    std::vector<T,A>& vec;
};

#include <string>
template<typename T = char> class JavaCPP_hidden StringAdapter {
public:
    StringAdapter(const          char* ptr, typename std::basic_string<T>::size_type size, void* owner) : ptr((T*)ptr), size(size), owner(owner),
        str2(ptr ? (T*)ptr : "", ptr ? (size > 0 ? size : strlen((char*)ptr)) : 0), str(str2) { }
    StringAdapter(const signed   char* ptr, typename std::basic_string<T>::size_type size, void* owner) : ptr((T*)ptr), size(size), owner(owner),
        str2(ptr ? (T*)ptr : "", ptr ? (size > 0 ? size : strlen((char*)ptr)) : 0), str(str2) { }
    StringAdapter(const unsigned char* ptr, typename std::basic_string<T>::size_type size, void* owner) : ptr((T*)ptr), size(size), owner(owner),
        str2(ptr ? (T*)ptr : "", ptr ? (size > 0 ? size : strlen((char*)ptr)) : 0), str(str2) { }
    StringAdapter(const       wchar_t* ptr, typename std::basic_string<T>::size_type size, void* owner) : ptr((T*)ptr), size(size), owner(owner),
        str2(ptr ? (T*)ptr : L"", ptr ? (size > 0 ? size : wcslen((wchar_t*)ptr)) : 0), str(str2) { }
    StringAdapter(const unsigned short* ptr, typename std::basic_string<T>::size_type size, void* owner) : ptr((T*)ptr), size(size), owner(owner),
        str2(ptr ? (T*)ptr : L"", ptr ? (size > 0 ? size : wcslen((wchar_t*)ptr)) : 0), str(str2) { }
    StringAdapter(const   signed   int* ptr, typename std::basic_string<T>::size_type size, void* owner) : ptr((T*)ptr), size(size), owner(owner),
        str2(ptr ? (T*)ptr : L"", ptr ? (size > 0 ? size : wcslen((wchar_t*)ptr)) : 0), str(str2) { }
    StringAdapter(const std::basic_string<T>& str) : ptr(0), size(0), owner(0), str2(str), str(str2) { }
    StringAdapter(      std::basic_string<T>& str) : ptr(0), size(0), owner(0), str(str) { }
    StringAdapter(const std::basic_string<T>* str) : ptr(0), size(0), owner(0), str(*(std::basic_string<T>*)str) { }
    void assign(char* ptr, typename std::basic_string<T>::size_type size, void* owner) {
        this->ptr = ptr;
        this->size = size;
        this->owner = owner;
        str.assign(ptr ? ptr : "", ptr ? (size > 0 ? size : strlen((char*)ptr)) : 0);
    }
    void assign(const          char* ptr, typename std::basic_string<T>::size_type size, void* owner) { assign((char*)ptr, size, owner); }
    void assign(const signed   char* ptr, typename std::basic_string<T>::size_type size, void* owner) { assign((char*)ptr, size, owner); }
    void assign(const unsigned char* ptr, typename std::basic_string<T>::size_type size, void* owner) { assign((char*)ptr, size, owner); }
    void assign(wchar_t* ptr, typename std::basic_string<T>::size_type size, void* owner) {
        this->ptr = ptr;
        this->size = size;
        this->owner = owner;
        str.assign(ptr ? ptr : L"", ptr ? (size > 0 ? size : wcslen((wchar_t*)ptr)) : 0);
    }
    void assign(const        wchar_t* ptr, typename std::basic_string<T>::size_type size, void* owner) { assign((wchar_t*)ptr, size, owner); }
    void assign(const unsigned short* ptr, typename std::basic_string<T>::size_type size, void* owner) { assign((wchar_t*)ptr, size, owner); }
    void assign(const   signed   int* ptr, typename std::basic_string<T>::size_type size, void* owner) { assign((wchar_t*)ptr, size, owner); }
    static void deallocate(void* owner) { delete[] (T*)owner; }
    operator char*() {
        const char* data = str.data();
        if (str.size() > size) {
            ptr = new (std::nothrow) char[str.size()+1];
            if (ptr) memset(ptr, 0, str.size()+1);
        }
        if (ptr && memcmp(ptr, data, str.size()) != 0) {
            memcpy(ptr, data, str.size());
            if (size > str.size()) ptr[str.size()] = 0;
        }
        size = str.size();
        owner = ptr;
        return ptr;
    }
    operator       signed   char*() { return (signed   char*)(operator char*)(); }
    operator       unsigned char*() { return (unsigned char*)(operator char*)(); }
    operator const          char*() { size = str.size(); return                 str.c_str(); }
    operator const signed   char*() { size = str.size(); return (signed   char*)str.c_str(); }
    operator const unsigned char*() { size = str.size(); return (unsigned char*)str.c_str(); }
    operator wchar_t*() {
        const wchar_t* data = str.data();
        if (str.size() > size) {
            ptr = new (std::nothrow) wchar_t[str.size()+1];
            if (ptr) memset(ptr, 0, sizeof(wchar_t) * (str.size()+1));
        }
        if (ptr && memcmp(ptr, data, sizeof(wchar_t) * str.size()) != 0) {
            memcpy(ptr, data, sizeof(wchar_t) * str.size());
            if (size > str.size()) ptr[str.size()] = 0;
        }
        size = str.size();
        owner = ptr;
        return ptr;
    }
    operator     unsigned   short*() { return (unsigned short*)(operator wchar_t*)(); }
    operator       signed     int*() { return (  signed   int*)(operator wchar_t*)(); }
    operator const        wchar_t*() { size = str.size(); return                  str.c_str(); }
    operator const unsigned short*() { size = str.size(); return (unsigned short*)str.c_str(); }
    operator const   signed   int*() { size = str.size(); return (  signed   int*)str.c_str(); }
    operator         std::basic_string<T>&() { return str; }
    operator         std::basic_string<T>*() { return ptr ? &str : 0; }
    T* ptr;
    typename std::basic_string<T>::size_type size;
    void* owner;
    std::basic_string<T> str2;
    std::basic_string<T>& str;
};

#ifdef SHARED_PTR_NAMESPACE
template<class T> class SharedPtrAdapter {
public:
    typedef SHARED_PTR_NAMESPACE::shared_ptr<T> S;
    SharedPtrAdapter(const T* ptr, size_t size, void* owner) : ptr((T*)ptr), size(size), owner(owner),
            sharedPtr2(owner != NULL && owner != ptr ? *(S*)owner : S((T*)ptr)), sharedPtr(sharedPtr2) { }
    SharedPtrAdapter(const S& sharedPtr) : ptr(0), size(0), owner(0), sharedPtr2(sharedPtr), sharedPtr(sharedPtr2) { }
    SharedPtrAdapter(      S& sharedPtr) : ptr(0), size(0), owner(0), sharedPtr(sharedPtr) { }
    SharedPtrAdapter(const S* sharedPtr) : ptr(0), size(0), owner(0), sharedPtr(*(S*)sharedPtr) { }
    void assign(T* ptr, size_t size, void* owner) {
        this->ptr = ptr;
        this->size = size;
        this->owner = owner;
        this->sharedPtr = owner != NULL && owner != ptr ? *(S*)owner : S((T*)ptr);
    }
    static void deallocate(void* owner) { delete (S*)owner; }
    operator typename SHARED_PTR_NAMESPACE::remove_const<T>::type*() {
        ptr = sharedPtr.get();
        if (owner == NULL || owner == ptr) {
            owner = new S(sharedPtr);
        }
        return (typename SHARED_PTR_NAMESPACE::remove_const<T>::type*)ptr;
    }
    operator S&() { return sharedPtr; }
    operator S*() { return &sharedPtr; }
    T* ptr;
    size_t size;
    void* owner;
    S sharedPtr2;
    S& sharedPtr;
};
#endif

#ifdef UNIQUE_PTR_NAMESPACE
template<class T, class D = UNIQUE_PTR_NAMESPACE::default_delete<T> > class UniquePtrAdapter {
public:
    typedef UNIQUE_PTR_NAMESPACE::unique_ptr<T,D> U;
    UniquePtrAdapter(const T* ptr, size_t size, void* owner) : ptr((T*)ptr), size(size), owner(owner),
            uniquePtr2(owner != NULL && owner != ptr ? U() : U((T*)ptr)),
            uniquePtr(owner != NULL && owner != ptr ? *(U*)owner : uniquePtr2) { }
    UniquePtrAdapter(U&& uniquePtr) : ptr(0), size(0), owner(0), uniquePtr2(UNIQUE_PTR_NAMESPACE::move(uniquePtr)), uniquePtr(uniquePtr2) { }
    UniquePtrAdapter(const U& uniquePtr) : ptr(0), size(0), owner(0), uniquePtr((U&)uniquePtr) { }
    UniquePtrAdapter(      U& uniquePtr) : ptr(0), size(0), owner(0), uniquePtr(uniquePtr) { }
    UniquePtrAdapter(const U* uniquePtr) : ptr(0), size(0), owner(0), uniquePtr(*(U*)uniquePtr) { }
    void assign(T* ptr, size_t size, void* owner) {
        this->ptr = ptr;
        this->size = size;
        this->owner = owner;
        this->uniquePtr = owner != NULL && owner != ptr ? *(U*)owner : U((T*)ptr);
    }
    static void deallocate(void* owner) { delete (U*)owner; }
    operator typename UNIQUE_PTR_NAMESPACE::remove_const<T>::type*() {
        ptr = uniquePtr.get();
        if (ptr == uniquePtr2.get() && (owner == NULL || owner == ptr)) {
            // only move the pointer if we actually own it through uniquePtr2
            owner = new U(UNIQUE_PTR_NAMESPACE::move(uniquePtr));
        }
        return (typename UNIQUE_PTR_NAMESPACE::remove_const<T>::type*)ptr;
    }
    operator U&() const { return uniquePtr; }
    operator U&&() { return UNIQUE_PTR_NAMESPACE::move(uniquePtr); }
    operator U*() { return &uniquePtr; }
    T* ptr;
    size_t size;
    void* owner;
    U uniquePtr2;
    U& uniquePtr;
};
#endif

#if __cplusplus >= 201103L || _MSC_VER >= 1900
#include <utility>
template<class T> class MoveAdapter {
public:
    MoveAdapter(const T* ptr, size_t size, void* owner) : ptr(&movedPtr), size(size), owner(owner), movedPtr(std::move(*(T*)ptr)) { }
    MoveAdapter(const T& ptr) : ptr(&movedPtr), size(0), owner(0), movedPtr(std::move((T&)ptr)) { }
    MoveAdapter(T&& ptr) : ptr(&movedPtr), size(0), owner(0), movedPtr((T&&)ptr) { }
    void assign(T* ptr, size_t size, void* owner) {
        this->ptr = &this->movedPtr;
        this->size = size;
        this->owner = owner;
        this->movedPtr = std::move(*ptr);
    }
    static void deallocate(void* owner) { delete (T*)owner; }
    operator T*() {
        ptr = new T(std::move(movedPtr));
        owner = ptr;
        return ptr;
    }
    operator const T*() { return ptr; }
    operator T&&() { return std::move(movedPtr); }
    T* ptr;
    size_t size;
    void* owner;
    T movedPtr;
};
#endif




static void JavaCPP_com_helixd2s_valera_ValerABase_00024Framebuffer_deallocate(void *p) { delete (::vlj::Framebuffer*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024PipelineLayout_deallocate(void *p) { delete (::vlj::PipelineLayout*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024Rasterization_deallocate(void *p) { delete (::vlj::Rasterization*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024RayTracing_deallocate(void *p) { delete (::vlj::RayTracing*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024BuildCommand_deallocate(void *p) { delete (::vlj::BuildCommand*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024RenderCommand_deallocate(void *p) { delete (::vlj::RenderCommand*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024SamplerSet_deallocate(void *p) { delete (::vlj::SamplerSet*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024TextureSet_deallocate(void *p) { delete (::vlj::TextureSet*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024BufferViewSet_deallocate(void *p) { delete (::vlj::BufferViewSet*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024Background_deallocate(void *p) { delete (::vlj::Background*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024GeometrySet_deallocate(void *p) { delete (::vlj::GeometrySet*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024Geometry_deallocate(void *p) { delete (::vlj::Geometry*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024Acceleration_deallocate(void *p) { delete (::vlj::Acceleration*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024VertexSet_deallocate(void *p) { delete (::vlj::VertexSet*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024InstanceSet_deallocate(void *p) { delete (::vlj::InstanceSet*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024Constants_deallocate(void *p) { delete (::vlj::Constants*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024MaterialSet_deallocate(void *p) { delete (::vlj::MaterialSet*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024BindingSet_deallocate(void *p) { delete (::vlj::BindingSet*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024AttributeSet_deallocate(void *p) { delete (::vlj::AttributeSet*)p; }
static void JavaCPP_com_helixd2s_valera_ValerABase_00024SetBase_deallocate(void *p) { delete (::vlj::SetBase*)p; }

static const char* JavaCPP_members[55][2] = {
        { NULL },
        { NULL },
        { NULL },
        { NULL },
        { NULL },
        { NULL },
        { "sizeof" },
        { NULL },
        { NULL },
        { NULL },
        { NULL },
        { "sizeof" },
        { NULL },
        { NULL },
        { "sizeof" },
        { NULL },
        { "sizeof" },
        { NULL },
        { "sizeof" },
        { NULL },
        { "sizeof" },
        { NULL },
        { "sizeof" },
        { NULL },
        { "sizeof" },
        { NULL },
        { "sizeof" },
        { NULL },
        { NULL },
        { "sizeof" },
        { NULL },
        { "sizeof" },
        { NULL },
        { NULL },
        { "sizeof" },
        { NULL },
        { "sizeof" },
        { NULL },
        { "sizeof" },
        { NULL },
        { "sizeof" },
        { NULL },
        { NULL },
        { "sizeof" },
        { NULL },
        { NULL },
        { "sizeof" },
        { NULL },
        { NULL },
        { "sizeof" },
        { NULL },
        { "sizeof" },
        { NULL },
        { "sizeof" },
        { NULL } };
static int JavaCPP_offsets[55][2] = {
        { -1 },
        { -1 },
        { -1 },
        { -1 },
        { -1 },
        { -1 },
        { sizeof(::vlj::Framebuffer) },
        { -1 },
        { -1 },
        { -1 },
        { -1 },
        { sizeof(::vlj::PipelineLayout) },
        { -1 },
        { -1 },
        { sizeof(::vlj::Rasterization) },
        { -1 },
        { sizeof(::vlj::RayTracing) },
        { -1 },
        { sizeof(::vlj::BuildCommand) },
        { -1 },
        { sizeof(::vlj::RenderCommand) },
        { -1 },
        { sizeof(::vlj::SamplerSet) },
        { -1 },
        { sizeof(::vlj::TextureSet) },
        { -1 },
        { sizeof(::vlj::BufferViewSet) },
        { -1 },
        { -1 },
        { sizeof(::vlj::Background) },
        { -1 },
        { sizeof(::vlj::GeometrySet) },
        { -1 },
        { -1 },
        { sizeof(::vlj::Geometry) },
        { -1 },
        { sizeof(::vlj::Acceleration) },
        { -1 },
        { sizeof(::vlj::VertexSet) },
        { -1 },
        { sizeof(::vlj::InstanceSet) },
        { -1 },
        { -1 },
        { sizeof(::vlj::Constants) },
        { -1 },
        { -1 },
        { sizeof(::vlj::MaterialSet) },
        { -1 },
        { -1 },
        { sizeof(::vlj::BindingSet) },
        { -1 },
        { sizeof(::vlj::AttributeSet) },
        { -1 },
        { sizeof(::vlj::SetBase) },
        { -1 } };
static int JavaCPP_memberOffsetSizes[55] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };

extern "C" {

JNIEXPORT jint JNICALL JNI_OnLoad_jnijavacpp(JavaVM* vm, void* reserved);
JNIEXPORT void JNICALL JNI_OnUnload_jnijavacpp(JavaVM* vm, void* reserved);

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) {
    if (JNI_OnLoad_jnijavacpp(vm, reserved) == JNI_ERR) {
        return JNI_ERR;
    }
    JNIEnv* env;
    if (vm->GetEnv((void**)&env, JNI_VERSION_1_6) != JNI_OK) {
        JavaCPP_log("Could not get JNIEnv for JNI_VERSION_1_6 inside JNI_OnLoad().");
        return JNI_ERR;
    }
    if (JavaCPP_vm == vm) {
        return env->GetVersion();
    }
    JavaCPP_vm = vm;
    JavaCPP_haveAllocObject = env->functions->AllocObject != NULL;
    JavaCPP_haveNonvirtual = env->functions->CallNonvirtualVoidMethodA != NULL;
    jmethodID putMemberOffsetMID = JavaCPP_getStaticMethodID(env, 3, "putMemberOffset", "(Ljava/lang/String;Ljava/lang/String;I)Ljava/lang/Class;");
    if (putMemberOffsetMID == NULL) {
        return JNI_ERR;
    }
    for (int i = 0; i < 55 && !env->ExceptionCheck(); i++) {
        for (int j = 0; j < JavaCPP_memberOffsetSizes[i] && !env->ExceptionCheck(); j++) {
            if (env->PushLocalFrame(3) == 0) {
                jvalue args[3];
                args[0].l = env->NewStringUTF(JavaCPP_classNames[i]);
                args[1].l = JavaCPP_members[i][j] == NULL ? NULL : env->NewStringUTF(JavaCPP_members[i][j]);
                args[2].i = JavaCPP_offsets[i][j];
                jclass cls = (jclass)env->CallStaticObjectMethodA(JavaCPP_getClass(env, 3), putMemberOffsetMID, args);
                if (env->ExceptionCheck()) {
                    JavaCPP_log("Error putting member offsets for class %s.", JavaCPP_classNames[i]);
                    return JNI_ERR;
                }
                JavaCPP_classes[i] = cls == NULL ? NULL : (jclass)env->NewWeakGlobalRef(cls);
                if (env->ExceptionCheck()) {
                    JavaCPP_log("Error creating global reference of class %s.", JavaCPP_classNames[i]);
                    return JNI_ERR;
                }
                env->PopLocalFrame(NULL);
            }
        }
    }
    JavaCPP_addressFID = JavaCPP_getFieldID(env, 0, "address", "J");
    if (JavaCPP_addressFID == NULL) {
        return JNI_ERR;
    }
    JavaCPP_positionFID = JavaCPP_getFieldID(env, 0, "position", "J");
    if (JavaCPP_positionFID == NULL) {
        return JNI_ERR;
    }
    JavaCPP_limitFID = JavaCPP_getFieldID(env, 0, "limit", "J");
    if (JavaCPP_limitFID == NULL) {
        return JNI_ERR;
    }
    JavaCPP_capacityFID = JavaCPP_getFieldID(env, 0, "capacity", "J");
    if (JavaCPP_capacityFID == NULL) {
        return JNI_ERR;
    }
    JavaCPP_deallocatorFID = JavaCPP_getFieldID(env, 0, "deallocator", "Lorg/bytedeco/javacpp/Pointer$Deallocator;");
    if (JavaCPP_deallocatorFID == NULL) {
        return JNI_ERR;
    }
    JavaCPP_ownerAddressFID = JavaCPP_getFieldID(env, 2, "ownerAddress", "J");
    if (JavaCPP_ownerAddressFID == NULL) {
        return JNI_ERR;
    }
    JavaCPP_initMID = JavaCPP_getMethodID(env, 0, "init", "(JJJJ)V");
    if (JavaCPP_initMID == NULL) {
        return JNI_ERR;
    }
    JavaCPP_arrayMID = JavaCPP_getMethodID(env, 4, "array", "()Ljava/lang/Object;");
    if (JavaCPP_arrayMID == NULL) {
        return JNI_ERR;
    }
    JavaCPP_arrayOffsetMID = JavaCPP_getMethodID(env, 4, "arrayOffset", "()I");
    if (JavaCPP_arrayOffsetMID == NULL) {
        return JNI_ERR;
    }
    JavaCPP_bufferPositionFID = JavaCPP_getFieldID(env, 4, "position", "I");
    if (JavaCPP_bufferPositionFID == NULL) {
        return JNI_ERR;
    }
    JavaCPP_bufferLimitFID = JavaCPP_getFieldID(env, 4, "limit", "I");
    if (JavaCPP_bufferLimitFID == NULL) {
        return JNI_ERR;
    }
    JavaCPP_bufferCapacityFID = JavaCPP_getFieldID(env, 4, "capacity", "I");
    if (JavaCPP_bufferCapacityFID == NULL) {
        return JNI_ERR;
    }
    JavaCPP_stringMID = JavaCPP_getMethodID(env, 1, "<init>", "([B)V");
    if (JavaCPP_stringMID == NULL) {
        return JNI_ERR;
    }
    JavaCPP_getBytesMID = JavaCPP_getMethodID(env, 1, "getBytes", "()[B");
    if (JavaCPP_getBytesMID == NULL) {
        return JNI_ERR;
    }
    JavaCPP_toStringMID = JavaCPP_getMethodID(env, 5, "toString", "()Ljava/lang/String;");
    if (JavaCPP_toStringMID == NULL) {
        return JNI_ERR;
    }
    return env->GetVersion();
}


JNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved) {
    JNIEnv* env;
    if (vm->GetEnv((void**)&env, JNI_VERSION_1_6) != JNI_OK) {
        JavaCPP_log("Could not get JNIEnv for JNI_VERSION_1_6 inside JNI_OnUnLoad().");
        return;
    }
    for (int i = 0; i < 55; i++) {
        env->DeleteWeakGlobalRef((jweak)JavaCPP_classes[i]);
        JavaCPP_classes[i] = NULL;
    }
    JNI_OnUnload_jnijavacpp(vm, reserved);
    JavaCPP_vm = NULL;
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Framebuffer_allocate__(JNIEnv* env, jobject obj) {
    jthrowable exc = NULL;
    try {
        ::vlj::Framebuffer* rptr = new ::vlj::Framebuffer();
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Framebuffer_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Framebuffer_allocate__Lcom_helixd2s_valera_ValerACore_00024Framebuffer_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::Framebuffer* ptr0 = arg0 == NULL ? NULL : (::vlr::Framebuffer*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::Framebuffer > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::Framebuffer* rptr = new ::vlj::Framebuffer(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Framebuffer_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::Framebuffer* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::Framebuffer >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Framebuffer_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::Framebuffer* rptr = new ::vlj::Framebuffer(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Framebuffer_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Framebuffer_createDescriptorSet(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::Framebuffer* ptr = (::vlj::Framebuffer*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::PipelineLayout > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->createDescriptorSet(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::PipelineLayout* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::PipelineLayout >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Framebuffer_imageToLinearCopyCommand(JNIEnv* env, jobject obj, jlong arg0, jint arg1) {
    ::vlj::Framebuffer* ptr = (::vlj::Framebuffer*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jthrowable exc = NULL;
    try {
        ptr->imageToLinearCopyCommand((VkCommandBuffer)arg0, (uint32_t)arg1);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Framebuffer_linearToImageCopyCommand(JNIEnv* env, jobject obj, jlong arg0, jint arg1) {
    ::vlj::Framebuffer* ptr = (::vlj::Framebuffer*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jthrowable exc = NULL;
    try {
        ptr->linearToImageCopyCommand((VkCommandBuffer)arg0, (uint32_t)arg1);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Framebuffer_createFramebuffer(JNIEnv* env, jobject obj, jint arg0, jint arg1) {
    ::vlj::Framebuffer* ptr = (::vlj::Framebuffer*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jthrowable exc = NULL;
    try {
        ptr->createFramebuffer((uint32_t)arg0, (uint32_t)arg1);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Framebuffer_createRenderPass(JNIEnv* env, jobject obj) {
    ::vlj::Framebuffer* ptr = (::vlj::Framebuffer*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jthrowable exc = NULL;
    try {
        ptr->createRenderPass();
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024Framebuffer_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::Framebuffer* ptr = (::vlj::Framebuffer*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::Framebuffer* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::Framebuffer > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::Framebuffer >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 9);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024Framebuffer_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::Framebuffer* ptr = (::vlj::Framebuffer*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::Framebuffer* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::Framebuffer > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::Framebuffer >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 9);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024Framebuffer_getFramebuffer(JNIEnv* env, jobject obj, jint arg0) {
    ::vlj::Framebuffer* ptr = (::vlj::Framebuffer*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vkt::ImageRegion* rptr;
    jthrowable exc = NULL;
    try {
        rptr = &ptr->getFramebuffer((uint32_t)arg0);
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 10);
            if (rarg != NULL) {
                env->SetLongField(rarg, JavaCPP_addressFID, ptr_to_jlong(rptr));
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_allocate__(JNIEnv* env, jobject obj) {
    jthrowable exc = NULL;
    try {
        ::vlj::PipelineLayout* rptr = new ::vlj::PipelineLayout();
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024PipelineLayout_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_allocate__Lcom_helixd2s_valera_ValerACore_00024PipelineLayout_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::PipelineLayout > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::PipelineLayout* rptr = new ::vlj::PipelineLayout(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024PipelineLayout_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::PipelineLayout* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::PipelineLayout >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::PipelineLayout* rptr = new ::vlj::PipelineLayout(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024PipelineLayout_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jlong JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_getTransformPipelineLayout(JNIEnv* env, jobject obj) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jlong rarg = 0;
    jthrowable exc = NULL;
    try {
        int64_t rval = (int64_t)ptr->getTransformPipelineLayout();
        rarg = (jlong)rval;
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jlong JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_getBindingPipelineLayout(JNIEnv* env, jobject obj) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jlong rarg = 0;
    jthrowable exc = NULL;
    try {
        int64_t rval = (int64_t)ptr->getBindingPipelineLayout();
        rarg = (jlong)rval;
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jlong JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_getDescriptorSetLayout(JNIEnv* env, jobject obj, jint arg0) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jlong rarg = 0;
    jthrowable exc = NULL;
    try {
        int64_t rval = (int64_t)ptr->getDescriptorSetLayout(arg0);
        rarg = (jlong)rval;
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::PipelineLayout* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::PipelineLayout > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::PipelineLayout >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 12);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::PipelineLayout* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::PipelineLayout > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::PipelineLayout >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 12);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_setMaterials(JNIEnv* env, jobject obj, jobject arg0, jobject arg1, jobject arg2) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::MaterialSet* ptr0 = arg0 == NULL ? NULL : (::vlr::MaterialSet*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::MaterialSet > adapter0(ptr0, size0, owner0);
    ::vlr::TextureSet* ptr1 = arg1 == NULL ? NULL : (::vlr::TextureSet*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong size1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_limitFID);
    void* owner1 = JavaCPP_getPointerOwner(env, arg1);
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    size1 -= position1;
    vkt::uni_ptr< ::vlr::TextureSet > adapter1(ptr1, size1, owner1);
    ::vlr::SamplerSet* ptr2 = arg2 == NULL ? NULL : (::vlr::SamplerSet*)jlong_to_ptr(env->GetLongField(arg2, JavaCPP_addressFID));
    jlong size2 = arg2 == NULL ? 0 : env->GetLongField(arg2, JavaCPP_limitFID);
    void* owner2 = JavaCPP_getPointerOwner(env, arg2);
    jlong position2 = arg2 == NULL ? 0 : env->GetLongField(arg2, JavaCPP_positionFID);
    ptr2 += position2;
    size2 -= position2;
    vkt::uni_ptr< ::vlr::SamplerSet > adapter2(ptr2, size2, owner2);
    jthrowable exc = NULL;
    try {
        ptr->setMaterials(adapter0, adapter1, adapter2);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::MaterialSet* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::MaterialSet >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    ::vlr::TextureSet* rptr1 = adapter1;
    jlong rsize1 = (jlong)adapter1.size;
    void* rowner1 = adapter1.owner;
    if (rptr1 != ptr1) {
        JavaCPP_initPointer(env, arg1, rptr1, rsize1, rowner1, &vkt::uni_ptr< ::vlr::TextureSet >::deallocate);
    } else {
        env->SetLongField(arg1, JavaCPP_limitFID, rsize1 + position1);
    }
    ::vlr::SamplerSet* rptr2 = adapter2;
    jlong rsize2 = (jlong)adapter2.size;
    void* rowner2 = adapter2.owner;
    if (rptr2 != ptr2) {
        JavaCPP_initPointer(env, arg2, rptr2, rsize2, rowner2, &vkt::uni_ptr< ::vlr::SamplerSet >::deallocate);
    } else {
        env->SetLongField(arg2, JavaCPP_limitFID, rsize2 + position2);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_setVertexSet(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::VertexSet* ptr0 = arg0 == NULL ? NULL : (::vlr::VertexSet*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::VertexSet > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->setVertexSet<vlr::VertexSet>(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::VertexSet* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::VertexSet >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_setFramebuffer(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::Framebuffer* ptr0 = arg0 == NULL ? NULL : (::vlr::Framebuffer*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::Framebuffer > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->setFramebuffer<vlr::Framebuffer>(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::Framebuffer* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::Framebuffer >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_setRayTracing(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::RayTracing* ptr0 = arg0 == NULL ? NULL : (::vlr::RayTracing*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::RayTracing > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->setRayTracing<vlr::RayTracing>(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::RayTracing* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::RayTracing >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jlong JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_getPipelineLayout(JNIEnv* env, jobject obj) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jlong rarg = 0;
    jthrowable exc = NULL;
    try {
        int64_t rval = (int64_t)ptr->getPipelineLayout();
        rarg = (jlong)rval;
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_setInstanceSet(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::InstanceSet* ptr0 = arg0 == NULL ? NULL : (::vlr::InstanceSet*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::InstanceSet > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->setInstanceSet<vlr::InstanceSet>(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::InstanceSet* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::InstanceSet >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jlong JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_getDescriptorSet(JNIEnv* env, jobject obj, jint arg0) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jlong rarg = 0;
    jthrowable exc = NULL;
    try {
        int64_t rval = (int64_t)ptr->getDescriptorSet(arg0);
        rarg = (jlong)rval;
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_setConstants(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::Constants* ptr0 = arg0 == NULL ? NULL : (::vlr::Constants*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::Constants > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->setConstants<vlr::Constants>(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::Constants* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::Constants >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jlong JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_getPipelineCache(JNIEnv* env, jobject obj) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jlong rarg = 0;
    jthrowable exc = NULL;
    try {
        int64_t rval = (int64_t)ptr->getPipelineCache();
        rarg = (jlong)rval;
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_setAccelerationTop(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::Acceleration* ptr0 = arg0 == NULL ? NULL : (::vlr::Acceleration*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::Acceleration > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->setAccelerationTop<vlr::Acceleration>(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::Acceleration* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::Acceleration >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_setRasterization(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::Rasterization* ptr0 = arg0 == NULL ? NULL : (::vlr::Rasterization*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::Rasterization > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->setRasterization<vlr::Rasterization>(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::Rasterization* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::Rasterization >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jlong JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_getDescriptorPool(JNIEnv* env, jobject obj) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jlong rarg = 0;
    jthrowable exc = NULL;
    try {
        int64_t rval = (int64_t)ptr->getDescriptorPool();
        rarg = (jlong)rval;
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_getDescriptorSets(JNIEnv* env, jobject obj) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    jlong* rptr;
    jthrowable exc = NULL;
    try {
        VectorAdapter< jlong > radapter(ptr->getDescriptorSets());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &VectorAdapter< jlong >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 13);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024PipelineLayout_setBackground(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::PipelineLayout* ptr = (::vlj::PipelineLayout*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::Background* ptr0 = arg0 == NULL ? NULL : (::vlr::Background*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::Background > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->setBackground<vlr::Background>(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::Background* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::Background >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Rasterization_allocate__(JNIEnv* env, jobject obj) {
    jthrowable exc = NULL;
    try {
        ::vlj::Rasterization* rptr = new ::vlj::Rasterization();
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Rasterization_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Rasterization_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::Rasterization* rptr = new ::vlj::Rasterization(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Rasterization_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Rasterization_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2Lcom_helixd2s_valera_ValerACore_00024PipelineCreateInfo_2(JNIEnv* env, jobject obj, jobject arg0, jobject arg1) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    ::vlr::PipelineCreateInfo* ptr1 = arg1 == NULL ? NULL : (::vlr::PipelineCreateInfo*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ::vlj::Rasterization* rptr = new ::vlj::Rasterization(adapter0, ptr1);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Rasterization_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Rasterization_allocate__Lcom_helixd2s_valera_ValerACore_00024Rasterization_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::Rasterization* ptr0 = arg0 == NULL ? NULL : (::vlr::Rasterization*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::Rasterization > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::Rasterization* rptr = new ::vlj::Rasterization(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Rasterization_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::Rasterization* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::Rasterization >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024Rasterization_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::Rasterization* ptr = (::vlj::Rasterization*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::Rasterization* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::Rasterization > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::Rasterization >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 15);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024Rasterization_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::Rasterization* ptr = (::vlj::Rasterization*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::Rasterization* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::Rasterization > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::Rasterization >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 15);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Rasterization_setInstanceSet(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::Rasterization* ptr = (::vlj::Rasterization*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::InstanceSet* ptr0 = arg0 == NULL ? NULL : (::vlr::InstanceSet*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::InstanceSet > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->setInstanceSet(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::InstanceSet* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::InstanceSet >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Rasterization_setConstants(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::Rasterization* ptr = (::vlj::Rasterization*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::Constants* ptr0 = arg0 == NULL ? NULL : (::vlr::Constants*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::Constants > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->setConstants(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::Constants* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::Constants >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Rasterization_setDescriptorSets(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::Rasterization* ptr = (::vlj::Rasterization*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::PipelineLayout > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->setDescriptorSets(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::PipelineLayout* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::PipelineLayout >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Rasterization_drawCommand(JNIEnv* env, jobject obj, jlong arg0, jobject arg1) {
    ::vlj::Rasterization* ptr = (::vlj::Rasterization*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    int* ptr1 = arg1 == NULL ? NULL : (int*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ptr->drawCommand((VkCommandBuffer)arg0, (glm::uvec4*)ptr1);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Rasterization_setCommand(JNIEnv* env, jobject obj, jlong arg0, jobject arg1) {
    ::vlj::Rasterization* ptr = (::vlj::Rasterization*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    int* ptr1 = arg1 == NULL ? NULL : (int*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ptr->setCommand((VkCommandBuffer)arg0, (glm::uvec4*)ptr1);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024RayTracing_allocate__(JNIEnv* env, jobject obj) {
    jthrowable exc = NULL;
    try {
        ::vlj::RayTracing* rptr = new ::vlj::RayTracing();
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024RayTracing_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024RayTracing_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::RayTracing* rptr = new ::vlj::RayTracing(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024RayTracing_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024RayTracing_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2Lcom_helixd2s_valera_ValerACore_00024RayTracingCreateInfo_2(JNIEnv* env, jobject obj, jobject arg0, jobject arg1) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    ::vlr::RayTracingCreateInfo* ptr1 = arg1 == NULL ? NULL : (::vlr::RayTracingCreateInfo*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ::vlj::RayTracing* rptr = new ::vlj::RayTracing(adapter0, ptr1);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024RayTracing_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024RayTracing_allocate__Lcom_helixd2s_valera_ValerACore_00024RayTracing_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::RayTracing* ptr0 = arg0 == NULL ? NULL : (::vlr::RayTracing*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::RayTracing > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::RayTracing* rptr = new ::vlj::RayTracing(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024RayTracing_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::RayTracing* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::RayTracing >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024RayTracing_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::RayTracing* ptr = (::vlj::RayTracing*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::RayTracing* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::RayTracing > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::RayTracing >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 17);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024RayTracing_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::RayTracing* ptr = (::vlj::RayTracing*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::RayTracing* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::RayTracing > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::RayTracing >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 17);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024RayTracing_setConstants(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::RayTracing* ptr = (::vlj::RayTracing*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::Constants* ptr0 = arg0 == NULL ? NULL : (::vlr::Constants*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::Constants > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->setConstants(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::Constants* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::Constants >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024RayTracing_setAccelerationTop(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::RayTracing* ptr = (::vlj::RayTracing*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::Acceleration* ptr0 = arg0 == NULL ? NULL : (::vlr::Acceleration*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::Acceleration > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->setAccelerationTop(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::Acceleration* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::Acceleration >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024RayTracing_setDescriptorSets(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::RayTracing* ptr = (::vlj::RayTracing*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::PipelineLayout > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->setDescriptorSets(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::PipelineLayout* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::PipelineLayout >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024RayTracing_setCommandFinal(JNIEnv* env, jobject obj, jlong arg0, jobject arg1) {
    ::vlj::RayTracing* ptr = (::vlj::RayTracing*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    int* ptr1 = arg1 == NULL ? NULL : (int*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ptr->setCommandFinal((VkCommandBuffer)arg0, (glm::uvec4*)ptr1);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024RayTracing_setCommand(JNIEnv* env, jobject obj, jlong arg0, jobject arg1) {
    ::vlj::RayTracing* ptr = (::vlj::RayTracing*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    int* ptr1 = arg1 == NULL ? NULL : (int*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ptr->setCommand((VkCommandBuffer)arg0, (glm::uvec4*)ptr1);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024BuildCommand_allocate__(JNIEnv* env, jobject obj) {
    jthrowable exc = NULL;
    try {
        ::vlj::BuildCommand* rptr = new ::vlj::BuildCommand();
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024BuildCommand_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024BuildCommand_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::BuildCommand* rptr = new ::vlj::BuildCommand(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024BuildCommand_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024BuildCommand_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2Lcom_helixd2s_valera_ValerACore_00024BuildCommandCreateInfo_2(JNIEnv* env, jobject obj, jobject arg0, jobject arg1) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    ::vlr::BuildCommandCreateInfo* ptr1 = arg1 == NULL ? NULL : (::vlr::BuildCommandCreateInfo*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ::vlj::BuildCommand* rptr = new ::vlj::BuildCommand(adapter0, ptr1);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024BuildCommand_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024BuildCommand_allocate__Lcom_helixd2s_valera_ValerACore_00024BuildCommand_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::BuildCommand* ptr0 = arg0 == NULL ? NULL : (::vlr::BuildCommand*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::BuildCommand > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::BuildCommand* rptr = new ::vlj::BuildCommand(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024BuildCommand_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::BuildCommand* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::BuildCommand >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024BuildCommand_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::BuildCommand* ptr = (::vlj::BuildCommand*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::BuildCommand* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::BuildCommand > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::BuildCommand >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 19);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024BuildCommand_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::BuildCommand* ptr = (::vlj::BuildCommand*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::BuildCommand* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::BuildCommand > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::BuildCommand >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 19);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024BuildCommand_setAccelerationTop(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::BuildCommand* ptr = (::vlj::BuildCommand*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::Acceleration* ptr0 = arg0 == NULL ? NULL : (::vlr::Acceleration*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::Acceleration > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->setAccelerationTop(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::Acceleration* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::Acceleration >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024BuildCommand_setDescriptorSets(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::BuildCommand* ptr = (::vlj::BuildCommand*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::PipelineLayout > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->setDescriptorSets(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::PipelineLayout* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::PipelineLayout >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024BuildCommand_setCommandTop(JNIEnv* env, jobject obj, jlong arg0, jobject arg1) {
    ::vlj::BuildCommand* ptr = (::vlj::BuildCommand*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    int* ptr1 = arg1 == NULL ? NULL : (int*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ptr->setCommandTop((VkCommandBuffer)arg0, (glm::uvec4*)ptr1);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024BuildCommand_setCommand(JNIEnv* env, jobject obj, jlong arg0, jobject arg1) {
    ::vlj::BuildCommand* ptr = (::vlj::BuildCommand*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    int* ptr1 = arg1 == NULL ? NULL : (int*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ptr->setCommand((VkCommandBuffer)arg0, (glm::uvec4*)ptr1);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024RenderCommand_allocate__(JNIEnv* env, jobject obj) {
    jthrowable exc = NULL;
    try {
        ::vlj::RenderCommand* rptr = new ::vlj::RenderCommand();
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024RenderCommand_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024RenderCommand_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::RenderCommand* rptr = new ::vlj::RenderCommand(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024RenderCommand_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024RenderCommand_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2Lcom_helixd2s_valera_ValerACore_00024RenderCommandCreateInfo_2(JNIEnv* env, jobject obj, jobject arg0, jobject arg1) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    ::vlr::RenderCommandCreateInfo* ptr1 = arg1 == NULL ? NULL : (::vlr::RenderCommandCreateInfo*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ::vlj::RenderCommand* rptr = new ::vlj::RenderCommand(adapter0, ptr1);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024RenderCommand_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024RenderCommand_allocate__Lcom_helixd2s_valera_ValerACore_00024RenderCommand_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::RenderCommand* ptr0 = arg0 == NULL ? NULL : (::vlr::RenderCommand*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::RenderCommand > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::RenderCommand* rptr = new ::vlj::RenderCommand(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024RenderCommand_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::RenderCommand* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::RenderCommand >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024RenderCommand_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::RenderCommand* ptr = (::vlj::RenderCommand*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::RenderCommand* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::RenderCommand > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::RenderCommand >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 21);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024RenderCommand_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::RenderCommand* ptr = (::vlj::RenderCommand*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::RenderCommand* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::RenderCommand > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::RenderCommand >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 21);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024RenderCommand_setRayTracing(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::RenderCommand* ptr = (::vlj::RenderCommand*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::RayTracing* ptr0 = arg0 == NULL ? NULL : (::vlr::RayTracing*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::RayTracing > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->setRayTracing(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::RayTracing* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::RayTracing >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024RenderCommand_setRasterization(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::RenderCommand* ptr = (::vlj::RenderCommand*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::Rasterization* ptr0 = arg0 == NULL ? NULL : (::vlr::Rasterization*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::Rasterization > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ptr->setRasterization(adapter0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::Rasterization* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::Rasterization >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024RenderCommand_setDescriptorSets(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::RenderCommand* ptr = (::vlj::RenderCommand*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->setDescriptorSets(*ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024RenderCommand_setCommand(JNIEnv* env, jobject obj, jlong arg0) {
    ::vlj::RenderCommand* ptr = (::vlj::RenderCommand*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jthrowable exc = NULL;
    try {
        ptr->setCommand((VkCommandBuffer)arg0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024SamplerSet_allocate__(JNIEnv* env, jobject obj) {
    jthrowable exc = NULL;
    try {
        ::vlj::SamplerSet* rptr = new ::vlj::SamplerSet();
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024SamplerSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024SamplerSet_allocate__Lcom_helixd2s_valera_ValerACore_00024SamplerSet_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::SamplerSet* ptr0 = arg0 == NULL ? NULL : (::vlr::SamplerSet*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::SamplerSet > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::SamplerSet* rptr = new ::vlj::SamplerSet(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024SamplerSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::SamplerSet* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::SamplerSet >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024SamplerSet_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::SamplerSet* rptr = new ::vlj::SamplerSet(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024SamplerSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024SamplerSet_get(JNIEnv* env, jobject obj, jint arg0) {
    ::vlj::SamplerSet* ptr = (::vlj::SamplerSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    long* rptr;
    jthrowable exc = NULL;
    try {
        rptr = (long*)&ptr->get(arg0);
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 13);
            if (rarg != NULL) {
                env->SetLongField(rarg, JavaCPP_addressFID, ptr_to_jlong(rptr));
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024SamplerSet_createDescriptorSet(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::SamplerSet* ptr = (::vlj::SamplerSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->createDescriptorSet(*ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024SamplerSet_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::SamplerSet* ptr = (::vlj::SamplerSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::SamplerSet* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::SamplerSet > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::SamplerSet >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 23);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024SamplerSet_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::SamplerSet* ptr = (::vlj::SamplerSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::SamplerSet* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::SamplerSet > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::SamplerSet >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 23);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024SamplerSet_pushSampler(JNIEnv* env, jobject obj, jlong arg0) {
    ::vlj::SamplerSet* ptr = (::vlj::SamplerSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jthrowable exc = NULL;
    try {
        ptr->pushSampler((VkSampler)arg0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024SamplerSet_resetSamplers(JNIEnv* env, jobject obj) {
    ::vlj::SamplerSet* ptr = (::vlj::SamplerSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jthrowable exc = NULL;
    try {
        ptr->resetSamplers();
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024TextureSet_allocate__(JNIEnv* env, jobject obj) {
    jthrowable exc = NULL;
    try {
        ::vlj::TextureSet* rptr = new ::vlj::TextureSet();
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024TextureSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024TextureSet_allocate__Lcom_helixd2s_valera_ValerACore_00024TextureSet_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::TextureSet* ptr0 = arg0 == NULL ? NULL : (::vlr::TextureSet*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::TextureSet > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::TextureSet* rptr = new ::vlj::TextureSet(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024TextureSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::TextureSet* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::TextureSet >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024TextureSet_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::TextureSet* rptr = new ::vlj::TextureSet(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024TextureSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024TextureSet_get(JNIEnv* env, jobject obj, jint arg0) {
    ::vlj::TextureSet* ptr = (::vlj::TextureSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vkt::ImageRegion* rptr;
    jthrowable exc = NULL;
    try {
        rptr = &ptr->get(arg0);
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 10);
            if (rarg != NULL) {
                env->SetLongField(rarg, JavaCPP_addressFID, ptr_to_jlong(rptr));
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024TextureSet_createDescriptorSet(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::TextureSet* ptr = (::vlj::TextureSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->createDescriptorSet(*ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024TextureSet_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::TextureSet* ptr = (::vlj::TextureSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::TextureSet* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::TextureSet > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::TextureSet >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 25);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024TextureSet_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::TextureSet* ptr = (::vlj::TextureSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::TextureSet* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::TextureSet > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::TextureSet >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 25);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024TextureSet_pushImage(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::TextureSet* ptr = (::vlj::TextureSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vkt::ImageRegion* ptr0 = arg0 == NULL ? NULL : (::vkt::ImageRegion*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->pushImage(*ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024TextureSet_resetImages(JNIEnv* env, jobject obj) {
    ::vlj::TextureSet* ptr = (::vlj::TextureSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jthrowable exc = NULL;
    try {
        ptr->resetImages();
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024BufferViewSet_allocate__(JNIEnv* env, jobject obj) {
    jthrowable exc = NULL;
    try {
        ::vlj::BufferViewSet* rptr = new ::vlj::BufferViewSet();
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024BufferViewSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024BufferViewSet_allocate__Lcom_helixd2s_valera_ValerACore_00024BufferViewSet_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::BufferViewSet* ptr0 = arg0 == NULL ? NULL : (::vlr::BufferViewSet*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::BufferViewSet > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::BufferViewSet* rptr = new ::vlj::BufferViewSet(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024BufferViewSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::BufferViewSet* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::BufferViewSet >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024BufferViewSet_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::BufferViewSet* rptr = new ::vlj::BufferViewSet(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024BufferViewSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024BufferViewSet_get(JNIEnv* env, jobject obj, jint arg0) {
    ::vlj::BufferViewSet* ptr = (::vlj::BufferViewSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vkt::VectorBase* rptr;
    jthrowable exc = NULL;
    try {
        rptr = &ptr->get(arg0);
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 27);
            if (rarg != NULL) {
                env->SetLongField(rarg, JavaCPP_addressFID, ptr_to_jlong(rptr));
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024BufferViewSet_createDescriptorSet(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::BufferViewSet* ptr = (::vlj::BufferViewSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->createDescriptorSet(*ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024BufferViewSet_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::BufferViewSet* ptr = (::vlj::BufferViewSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::BufferViewSet* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::BufferViewSet > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::BufferViewSet >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 28);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024BufferViewSet_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::BufferViewSet* ptr = (::vlj::BufferViewSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::BufferViewSet* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::BufferViewSet > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::BufferViewSet >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 28);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024BufferViewSet_resetBufferViews(JNIEnv* env, jobject obj) {
    ::vlj::BufferViewSet* ptr = (::vlj::BufferViewSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jthrowable exc = NULL;
    try {
        ptr->resetBufferViews();
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024BufferViewSet_pushBufferView(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::BufferViewSet* ptr = (::vlj::BufferViewSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vkt::VectorBase* ptr0 = arg0 == NULL ? NULL : (::vkt::VectorBase*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->pushBufferView(*ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Background_allocate__(JNIEnv* env, jobject obj) {
    jthrowable exc = NULL;
    try {
        ::vlj::Background* rptr = new ::vlj::Background();
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Background_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Background_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2Lcom_helixd2s_valera_VKt_00024ImageRegion_2(JNIEnv* env, jobject obj, jobject arg0, jobject arg1) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    ::vkt::ImageRegion* ptr1 = arg1 == NULL ? NULL : (::vkt::ImageRegion*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ::vlj::Background* rptr = new ::vlj::Background(adapter0, ptr1);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Background_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Background_allocate__Lcom_helixd2s_valera_ValerACore_00024Background_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::Background* ptr0 = arg0 == NULL ? NULL : (::vlr::Background*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::Background > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::Background* rptr = new ::vlj::Background(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Background_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::Background* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::Background >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Background_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::Background* rptr = new ::vlj::Background(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Background_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Background_createDescriptorSet(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::Background* ptr = (::vlj::Background*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->createDescriptorSet(*ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024Background_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::Background* ptr = (::vlj::Background*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::Background* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::Background > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::Background >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 30);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024Background_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::Background* ptr = (::vlj::Background*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::Background* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::Background > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::Background >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 30);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Background_setImage(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::Background* ptr = (::vlj::Background*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vkt::ImageRegion* ptr0 = arg0 == NULL ? NULL : (::vkt::ImageRegion*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->setImage(*ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024GeometrySet_allocate__(JNIEnv* env, jobject obj) {
    jthrowable exc = NULL;
    try {
        ::vlj::GeometrySet* rptr = new ::vlj::GeometrySet();
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024GeometrySet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024GeometrySet_allocate__Lcom_helixd2s_valera_ValerACore_00024VertexSet_2Lcom_helixd2s_valera_ValerACore_00024DataSetCreateInfo_2(JNIEnv* env, jobject obj, jobject arg0, jobject arg1) {
    ::vlr::VertexSet* ptr0 = arg0 == NULL ? NULL : (::vlr::VertexSet*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    ::vlr::DataSetCreateInfo* ptr1 = arg1 == NULL ? NULL : (::vlr::DataSetCreateInfo*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ::vlj::GeometrySet* rptr = new ::vlj::GeometrySet(ptr0, ptr1);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024GeometrySet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024GeometrySet_allocate__Lcom_helixd2s_valera_ValerACore_00024GeometrySet_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::GeometrySet* ptr0 = arg0 == NULL ? NULL : (::vlr::GeometrySet*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::GeometrySet > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::GeometrySet* rptr = new ::vlj::GeometrySet(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024GeometrySet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::GeometrySet* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::GeometrySet >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024GeometrySet_allocate__Lcom_helixd2s_valera_ValerACore_00024VertexSet_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::VertexSet* ptr0 = arg0 == NULL ? NULL : (::vlr::VertexSet*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ::vlj::GeometrySet* rptr = new ::vlj::GeometrySet(ptr0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024GeometrySet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024GeometrySet_get(JNIEnv* env, jobject obj, jint arg0) {
    ::vlj::GeometrySet* ptr = (::vlj::GeometrySet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::GeometryDesc* rptr;
    jthrowable exc = NULL;
    try {
        rptr = ptr->get(arg0);
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 32);
            if (rarg != NULL) {
                env->SetLongField(rarg, JavaCPP_addressFID, ptr_to_jlong(rptr));
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024GeometrySet_createDescriptorSet(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::GeometrySet* ptr = (::vlj::GeometrySet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->createDescriptorSet(*ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024GeometrySet_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::GeometrySet* ptr = (::vlj::GeometrySet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::GeometrySet* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::GeometrySet > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::GeometrySet >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 33);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024GeometrySet_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::GeometrySet* ptr = (::vlj::GeometrySet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::GeometrySet* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::GeometrySet > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::GeometrySet >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 33);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Geometry_allocate__(JNIEnv* env, jobject obj) {
    jthrowable exc = NULL;
    try {
        ::vlj::Geometry* rptr = new ::vlj::Geometry();
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Geometry_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Geometry_allocate__Lcom_helixd2s_valera_ValerACore_00024VertexSet_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::VertexSet* ptr0 = arg0 == NULL ? NULL : (::vlr::VertexSet*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::VertexSet > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::Geometry* rptr = new ::vlj::Geometry(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Geometry_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::VertexSet* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::VertexSet >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Geometry_allocate__Lcom_helixd2s_valera_ValerACore_00024Geometry_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::Geometry* ptr0 = arg0 == NULL ? NULL : (::vlr::Geometry*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::Geometry > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::Geometry* rptr = new ::vlj::Geometry(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Geometry_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::Geometry* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::Geometry >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Geometry_allocate__Lcom_helixd2s_valera_ValerACore_00024VertexSet_2Lcom_helixd2s_valera_ValerACore_00024GeometryDesc_2(JNIEnv* env, jobject obj, jobject arg0, jobject arg1) {
    ::vlr::VertexSet* ptr0 = arg0 == NULL ? NULL : (::vlr::VertexSet*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::VertexSet > adapter0(ptr0, size0, owner0);
    ::vlr::GeometryDesc* ptr1 = arg1 == NULL ? NULL : (::vlr::GeometryDesc*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ::vlj::Geometry* rptr = new ::vlj::Geometry(adapter0, ptr1);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Geometry_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::VertexSet* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::VertexSet >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024Geometry_getDesc(JNIEnv* env, jobject obj) {
    ::vlj::Geometry* ptr = (::vlj::Geometry*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::GeometryDesc* rptr;
    jthrowable exc = NULL;
    try {
        rptr = ptr->getDesc();
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 32);
            if (rarg != NULL) {
                env->SetLongField(rarg, JavaCPP_addressFID, ptr_to_jlong(rptr));
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024Geometry_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::Geometry* ptr = (::vlj::Geometry*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::Geometry* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::Geometry > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::Geometry >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 35);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024Geometry_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::Geometry* ptr = (::vlj::Geometry*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::Geometry* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::Geometry > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::Geometry >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 35);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Geometry_setVertexBuffer(JNIEnv* env, jobject obj, jint arg0) {
    ::vlj::Geometry* ptr = (::vlj::Geometry*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jthrowable exc = NULL;
    try {
        ptr->setVertexBuffer((uint32_t)arg0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Geometry_setIndexBuffer(JNIEnv* env, jobject obj, jint arg0, jint arg1) {
    ::vlj::Geometry* ptr = (::vlj::Geometry*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jthrowable exc = NULL;
    try {
        ptr->setIndexBuffer((uint32_t)arg0, (VkIndexType)arg1);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Acceleration_allocate__(JNIEnv* env, jobject obj) {
    jthrowable exc = NULL;
    try {
        ::vlj::Acceleration* rptr = new ::vlj::Acceleration();
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Acceleration_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Acceleration_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2Lcom_helixd2s_valera_ValerACore_00024AccelerationCreateInfo_2(JNIEnv* env, jobject obj, jobject arg0, jobject arg1) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    ::vlr::AccelerationCreateInfo* ptr1 = arg1 == NULL ? NULL : (::vlr::AccelerationCreateInfo*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ::vlj::Acceleration* rptr = new ::vlj::Acceleration(adapter0, ptr1);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Acceleration_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Acceleration_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::Acceleration* rptr = new ::vlj::Acceleration(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Acceleration_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Acceleration_allocate__Lcom_helixd2s_valera_ValerACore_00024Acceleration_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::Acceleration* ptr0 = arg0 == NULL ? NULL : (::vlr::Acceleration*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::Acceleration > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::Acceleration* rptr = new ::vlj::Acceleration(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Acceleration_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::Acceleration* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::Acceleration >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jlong JNICALL Java_com_helixd2s_valera_ValerABase_00024Acceleration_getHandle(JNIEnv* env, jobject obj) {
    ::vlj::Acceleration* ptr = (::vlj::Acceleration*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jlong rarg = 0;
    jthrowable exc = NULL;
    try {
        int64_t rval = (int64_t)ptr->getHandle();
        rarg = (jlong)rval;
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Acceleration_updateAccelerationStructure(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::Acceleration* ptr = (::vlj::Acceleration*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::AccelerationCreateInfo* ptr0 = arg0 == NULL ? NULL : (::vlr::AccelerationCreateInfo*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->updateAccelerationStructure(ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Acceleration_createDescriptorSet(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::Acceleration* ptr = (::vlj::Acceleration*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->createDescriptorSet(*ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024Acceleration_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::Acceleration* ptr = (::vlj::Acceleration*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::Acceleration* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::Acceleration > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::Acceleration >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 37);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024Acceleration_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::Acceleration* ptr = (::vlj::Acceleration*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::Acceleration* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::Acceleration > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::Acceleration >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 37);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Acceleration_setCommand(JNIEnv* env, jobject obj, jlong arg0) {
    ::vlj::Acceleration* ptr = (::vlj::Acceleration*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jthrowable exc = NULL;
    try {
        ptr->setCommand((VkCommandBuffer)arg0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Acceleration_setInstanceCount(JNIEnv* env, jobject obj, jlong arg0) {
    ::vlj::Acceleration* ptr = (::vlj::Acceleration*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jthrowable exc = NULL;
    try {
        ptr->setInstanceCount((VkDeviceSize)arg0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024VertexSet_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::VertexSet* rptr = new ::vlj::VertexSet(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024VertexSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024VertexSet_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2Lcom_helixd2s_valera_ValerACore_00024VertexSetCreateInfo_2(JNIEnv* env, jobject obj, jobject arg0, jobject arg1) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    ::vlr::VertexSetCreateInfo* ptr1 = arg1 == NULL ? NULL : (::vlr::VertexSetCreateInfo*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ::vlj::VertexSet* rptr = new ::vlj::VertexSet(adapter0, ptr1);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024VertexSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024VertexSet_allocate__Lcom_helixd2s_valera_ValerACore_00024VertexSet_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::VertexSet* ptr0 = arg0 == NULL ? NULL : (::vlr::VertexSet*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::VertexSet > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::VertexSet* rptr = new ::vlj::VertexSet(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024VertexSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::VertexSet* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::VertexSet >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024VertexSet_allocate__(JNIEnv* env, jobject obj) {
    jthrowable exc = NULL;
    try {
        ::vlj::VertexSet* rptr = new ::vlj::VertexSet();
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024VertexSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024VertexSet_createDescriptorSet(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::VertexSet* ptr = (::vlj::VertexSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->createDescriptorSet(*ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024VertexSet_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::VertexSet* ptr = (::vlj::VertexSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::VertexSet* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::VertexSet > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::VertexSet >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 39);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024VertexSet_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::VertexSet* ptr = (::vlj::VertexSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::VertexSet* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::VertexSet > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::VertexSet >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 39);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024InstanceSet_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2Lcom_helixd2s_valera_ValerACore_00024DataSetCreateInfo_2(JNIEnv* env, jobject obj, jobject arg0, jobject arg1) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    ::vlr::DataSetCreateInfo* ptr1 = arg1 == NULL ? NULL : (::vlr::DataSetCreateInfo*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ::vlj::InstanceSet* rptr = new ::vlj::InstanceSet(adapter0, ptr1);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024InstanceSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024InstanceSet_allocate__Lcom_helixd2s_valera_ValerACore_00024InstanceSet_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::InstanceSet* ptr0 = arg0 == NULL ? NULL : (::vlr::InstanceSet*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::InstanceSet > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::InstanceSet* rptr = new ::vlj::InstanceSet(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024InstanceSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::InstanceSet* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::InstanceSet >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024InstanceSet_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::InstanceSet* rptr = new ::vlj::InstanceSet(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024InstanceSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024InstanceSet_get(JNIEnv* env, jobject obj, jint arg0) {
    ::vlj::InstanceSet* ptr = (::vlj::InstanceSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vkh::VsGeometryInstance* rptr;
    jthrowable exc = NULL;
    try {
        rptr = ptr->get(arg0);
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 41);
            if (rarg != NULL) {
                env->SetLongField(rarg, JavaCPP_addressFID, ptr_to_jlong(rptr));
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024InstanceSet_createDescriptorSet(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::InstanceSet* ptr = (::vlj::InstanceSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->createDescriptorSet(*ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024InstanceSet_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::InstanceSet* ptr = (::vlj::InstanceSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::InstanceSet* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::InstanceSet > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::InstanceSet >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 42);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024InstanceSet_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::InstanceSet* ptr = (::vlj::InstanceSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::InstanceSet* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::InstanceSet > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::InstanceSet >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 42);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024InstanceSet_pushAcceleration(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::InstanceSet* ptr = (::vlj::InstanceSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::Acceleration* ptr0 = arg0 == NULL ? NULL : (::vlr::Acceleration*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->pushAcceleration(*ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Constants_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::Constants* rptr = new ::vlj::Constants(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Constants_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Constants_allocate__Lcom_helixd2s_valera_ValerACore_00024Constants_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::Constants* ptr0 = arg0 == NULL ? NULL : (::vlr::Constants*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::Constants > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::Constants* rptr = new ::vlj::Constants(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Constants_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::Constants* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::Constants >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Constants_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2Lcom_helixd2s_valera_ValerACore_00024DataSetCreateInfo_2(JNIEnv* env, jobject obj, jobject arg0, jobject arg1) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    ::vlr::DataSetCreateInfo* ptr1 = arg1 == NULL ? NULL : (::vlr::DataSetCreateInfo*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ::vlj::Constants* rptr = new ::vlj::Constants(adapter0, ptr1);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024Constants_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024Constants_get__(JNIEnv* env, jobject obj) {
    ::vlj::Constants* ptr = (::vlj::Constants*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::ConstantDesc* rptr;
    jthrowable exc = NULL;
    try {
        rptr = ptr->get();
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 44);
            if (rarg != NULL) {
                env->SetLongField(rarg, JavaCPP_addressFID, ptr_to_jlong(rptr));
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024Constants_get__I(JNIEnv* env, jobject obj, jint arg0) {
    ::vlj::Constants* ptr = (::vlj::Constants*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::ConstantDesc* rptr;
    jthrowable exc = NULL;
    try {
        rptr = ptr->get(arg0);
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 44);
            if (rarg != NULL) {
                env->SetLongField(rarg, JavaCPP_addressFID, ptr_to_jlong(rptr));
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024Constants_createDescriptorSet(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::Constants* ptr = (::vlj::Constants*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->createDescriptorSet(*ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024Constants_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::Constants* ptr = (::vlj::Constants*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::Constants* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::Constants > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::Constants >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 45);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024Constants_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::Constants* ptr = (::vlj::Constants*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::Constants* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::Constants > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::Constants >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 45);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024MaterialSet_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::MaterialSet* rptr = new ::vlj::MaterialSet(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024MaterialSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024MaterialSet_allocate__Lcom_helixd2s_valera_ValerACore_00024MaterialSet_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::MaterialSet* ptr0 = arg0 == NULL ? NULL : (::vlr::MaterialSet*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::MaterialSet > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::MaterialSet* rptr = new ::vlj::MaterialSet(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024MaterialSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::MaterialSet* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::MaterialSet >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024MaterialSet_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2Lcom_helixd2s_valera_ValerACore_00024DataSetCreateInfo_2(JNIEnv* env, jobject obj, jobject arg0, jobject arg1) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    ::vlr::DataSetCreateInfo* ptr1 = arg1 == NULL ? NULL : (::vlr::DataSetCreateInfo*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ::vlj::MaterialSet* rptr = new ::vlj::MaterialSet(adapter0, ptr1);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024MaterialSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024MaterialSet_get(JNIEnv* env, jobject obj, jint arg0) {
    ::vlj::MaterialSet* ptr = (::vlj::MaterialSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::MaterialUnit* rptr;
    jthrowable exc = NULL;
    try {
        rptr = ptr->get(arg0);
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 47);
            if (rarg != NULL) {
                env->SetLongField(rarg, JavaCPP_addressFID, ptr_to_jlong(rptr));
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024MaterialSet_createDescriptorSet(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::MaterialSet* ptr = (::vlj::MaterialSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->createDescriptorSet(*ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024MaterialSet_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::MaterialSet* ptr = (::vlj::MaterialSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::MaterialSet* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::MaterialSet > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::MaterialSet >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 48);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024MaterialSet_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::MaterialSet* ptr = (::vlj::MaterialSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::MaterialSet* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::MaterialSet > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::MaterialSet >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 48);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024BindingSet_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::BindingSet* rptr = new ::vlj::BindingSet(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024BindingSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024BindingSet_allocate__Lcom_helixd2s_valera_ValerACore_00024BindingSet_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::BindingSet* ptr0 = arg0 == NULL ? NULL : (::vlr::BindingSet*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::BindingSet > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::BindingSet* rptr = new ::vlj::BindingSet(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024BindingSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::BindingSet* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::BindingSet >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024BindingSet_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2Lcom_helixd2s_valera_ValerACore_00024DataSetCreateInfo_2(JNIEnv* env, jobject obj, jobject arg0, jobject arg1) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    ::vlr::DataSetCreateInfo* ptr1 = arg1 == NULL ? NULL : (::vlr::DataSetCreateInfo*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ::vlj::BindingSet* rptr = new ::vlj::BindingSet(adapter0, ptr1);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024BindingSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jlong JNICALL Java_com_helixd2s_valera_ValerABase_00024BindingSet_get__(JNIEnv* env, jobject obj) {
    ::vlj::BindingSet* ptr = (::vlj::BindingSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jlong rarg = 0;
    jthrowable exc = NULL;
    try {
        long rval = (long)ptr->get();
        rarg = (jlong)rval;
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jlong JNICALL Java_com_helixd2s_valera_ValerABase_00024BindingSet_get__I(JNIEnv* env, jobject obj, jint arg0) {
    ::vlj::BindingSet* ptr = (::vlj::BindingSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jlong rarg = 0;
    jthrowable exc = NULL;
    try {
        long rval = (long)ptr->get(arg0);
        rarg = (jlong)rval;
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024BindingSet_createDescriptorSet(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::BindingSet* ptr = (::vlj::BindingSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->createDescriptorSet(*ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024BindingSet_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::BindingSet* ptr = (::vlj::BindingSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::BindingSet* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::BindingSet > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::BindingSet >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 50);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024BindingSet_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::BindingSet* ptr = (::vlj::BindingSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::BindingSet* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::BindingSet > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::BindingSet >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 50);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024AttributeSet_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::AttributeSet* rptr = new ::vlj::AttributeSet(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024AttributeSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024AttributeSet_allocate__Lcom_helixd2s_valera_ValerACore_00024AttributeSet_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::AttributeSet* ptr0 = arg0 == NULL ? NULL : (::vlr::AttributeSet*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::AttributeSet > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::AttributeSet* rptr = new ::vlj::AttributeSet(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024AttributeSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::AttributeSet* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::AttributeSet >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024AttributeSet_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2Lcom_helixd2s_valera_ValerACore_00024DataSetCreateInfo_2(JNIEnv* env, jobject obj, jobject arg0, jobject arg1) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    ::vlr::DataSetCreateInfo* ptr1 = arg1 == NULL ? NULL : (::vlr::DataSetCreateInfo*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ::vlj::AttributeSet* rptr = new ::vlj::AttributeSet(adapter0, ptr1);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024AttributeSet_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jlong JNICALL Java_com_helixd2s_valera_ValerABase_00024AttributeSet_get__(JNIEnv* env, jobject obj) {
    ::vlj::AttributeSet* ptr = (::vlj::AttributeSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jlong rarg = 0;
    jthrowable exc = NULL;
    try {
        long rval = (long)ptr->get();
        rarg = (jlong)rval;
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jlong JNICALL Java_com_helixd2s_valera_ValerABase_00024AttributeSet_get__I(JNIEnv* env, jobject obj, jint arg0) {
    ::vlj::AttributeSet* ptr = (::vlj::AttributeSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jlong rarg = 0;
    jthrowable exc = NULL;
    try {
        long rval = (long)ptr->get(arg0);
        rarg = (jlong)rval;
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024AttributeSet_createDescriptorSet(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::AttributeSet* ptr = (::vlj::AttributeSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->createDescriptorSet(*ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024AttributeSet_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::AttributeSet* ptr = (::vlj::AttributeSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::AttributeSet* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::AttributeSet > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::AttributeSet >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 52);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024AttributeSet_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::AttributeSet* ptr = (::vlj::AttributeSet*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::AttributeSet* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::AttributeSet > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::AttributeSet >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 52);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}

JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024SetBase_allocate__(JNIEnv* env, jobject obj) {
    jthrowable exc = NULL;
    try {
        ::vlj::SetBase* rptr = new ::vlj::SetBase();
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024SetBase_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024SetBase_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2Lcom_helixd2s_valera_ValerACore_00024DataSetCreateInfo_2(JNIEnv* env, jobject obj, jobject arg0, jobject arg1) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    ::vlr::DataSetCreateInfo* ptr1 = arg1 == NULL ? NULL : (::vlr::DataSetCreateInfo*)jlong_to_ptr(env->GetLongField(arg1, JavaCPP_addressFID));
    jlong position1 = arg1 == NULL ? 0 : env->GetLongField(arg1, JavaCPP_positionFID);
    ptr1 += position1;
    jthrowable exc = NULL;
    try {
        ::vlj::SetBase* rptr = new ::vlj::SetBase(adapter0, ptr1);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024SetBase_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024SetBase_allocate__Lcom_helixd2s_valera_ValerACore_00024SetBase_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlr::SetBase* ptr0 = arg0 == NULL ? NULL : (::vlr::SetBase*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vlr::SetBase > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::SetBase* rptr = new ::vlj::SetBase(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024SetBase_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vlr::SetBase* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vlr::SetBase >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024SetBase_allocate__Lcom_helixd2s_valera_VKt_00024Driver_2(JNIEnv* env, jobject obj, jobject arg0) {
    ::vkt::GPUFramework* ptr0 = arg0 == NULL ? NULL : (::vkt::GPUFramework*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    jlong size0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_limitFID);
    void* owner0 = JavaCPP_getPointerOwner(env, arg0);
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    size0 -= position0;
    vkt::uni_ptr< ::vkt::GPUFramework > adapter0(ptr0, size0, owner0);
    jthrowable exc = NULL;
    try {
        ::vlj::SetBase* rptr = new ::vlj::SetBase(adapter0);
        jlong rcapacity = 1;
        JavaCPP_initPointer(env, obj, rptr, rcapacity, rptr, &JavaCPP_com_helixd2s_valera_ValerABase_00024SetBase_deallocate);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    ::vkt::GPUFramework* rptr0 = adapter0;
    jlong rsize0 = (jlong)adapter0.size;
    void* rowner0 = adapter0.owner;
    if (rptr0 != ptr0) {
        JavaCPP_initPointer(env, arg0, rptr0, rsize0, rowner0, &vkt::uni_ptr< ::vkt::GPUFramework >::deallocate);
    } else {
        env->SetLongField(arg0, JavaCPP_limitFID, rsize0 + position0);
    }
    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT void JNICALL Java_com_helixd2s_valera_ValerABase_00024SetBase_createDescriptorSet(JNIEnv* env, jobject obj, jobject arg0) {
    ::vlj::SetBase* ptr = (::vlj::SetBase*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    ::vlr::PipelineLayout* ptr0 = arg0 == NULL ? NULL : (::vlr::PipelineLayout*)jlong_to_ptr(env->GetLongField(arg0, JavaCPP_addressFID));
    if (ptr0 == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "Pointer address of argument 0 is NULL.");
        return;
    }
    jlong position0 = arg0 == NULL ? 0 : env->GetLongField(arg0, JavaCPP_positionFID);
    ptr0 += position0;
    jthrowable exc = NULL;
    try {
        ptr->createDescriptorSet(*ptr0);
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024SetBase_sharedPtr(JNIEnv* env, jobject obj) {
    ::vlj::SetBase* ptr = (::vlj::SetBase*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::SetBase* rptr;
    jthrowable exc = NULL;
    try {
        SharedPtrAdapter< ::vlr::SetBase > radapter(ptr->sharedPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &SharedPtrAdapter< ::vlr::SetBase >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 54);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024SetBase_uniPtr(JNIEnv* env, jobject obj) {
    ::vlj::SetBase* ptr = (::vlj::SetBase*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vlr::SetBase* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vlr::SetBase > radapter(ptr->uniPtr());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vlr::SetBase >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 54);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024SetBase_getCpuBuffer(JNIEnv* env, jobject obj) {
    ::vlj::SetBase* ptr = (::vlj::SetBase*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vkt::VectorBase* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vkt::VectorBase > radapter(ptr->getCpuBuffer());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vkt::VectorBase >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 27);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}
JNIEXPORT jobject JNICALL Java_com_helixd2s_valera_ValerABase_00024SetBase_getGpuBuffer(JNIEnv* env, jobject obj) {
    ::vlj::SetBase* ptr = (::vlj::SetBase*)jlong_to_ptr(env->GetLongField(obj, JavaCPP_addressFID));
    if (ptr == NULL) {
        env->ThrowNew(JavaCPP_getClass(env, 8), "This pointer address is NULL.");
        return 0;
    }
    jlong position = env->GetLongField(obj, JavaCPP_positionFID);
    ptr += position;
    jobject rarg = NULL;
    ::vkt::VectorBase* rptr;
    jthrowable exc = NULL;
    try {
        vkt::uni_ptr< ::vkt::VectorBase > radapter(ptr->getGpuBuffer());
        rptr = radapter;
        jlong rcapacity = (jlong)radapter.size;
        void* rowner = radapter.owner;
        void (*deallocator)(void*) = rowner != NULL ? &vkt::uni_ptr< ::vkt::VectorBase >::deallocate : 0;
        if (rptr != NULL) {
            rarg = JavaCPP_createPointer(env, 27);
            if (rarg != NULL) {
                JavaCPP_initPointer(env, rarg, rptr, rcapacity, rowner, deallocator);
            }
        }
    } catch (...) {
        exc = JavaCPP_handleException(env, 7);
    }

    if (exc != NULL) {
        env->Throw(exc);
    }
    return rarg;
}


}

